(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{327:function(t,e,a){"use strict";a.r(e);var n=a(16),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"二面-三面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二面-三面"}},[t._v("#")]),t._v(" 二面/三面")]),t._v(" "),a("h2",{attrs:{id:"渲染机制类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染机制类"}},[t._v("#")]),t._v(" 渲染机制类")]),t._v(" "),a("p",[t._v("什么是DOCTYPE以及作用\nHTML5\nHTML4.0.1 Strict该DTD包含所有HTML元素和属性，但不包含展示型和弃用的元素（比如font）（后面是strict.dtd）\nHTML4.0.1 Transitional DTD包含所有HTML和属性，包含展示性和弃用的元素，比如font（后面是loose.dtd）")]),t._v(" "),a("h3",{attrs:{id:"浏览器的渲染过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的渲染过程"}},[t._v("#")]),t._v(" 浏览器的渲染过程")]),t._v(" "),a("p",[t._v("Html dom tree\ncss tree\n两个树整合，变成Rneder Tree 通过Layout精确显示，Painting Display（可以看到效果）")]),t._v(" "),a("p",[t._v("渲染机制类 重排Reflow")]),t._v(" "),a("p",[t._v("定义\nDOM结构中各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式计算并根据计算结果将元素放到该出现的位置，这个过程称为Reflow")]),t._v(" "),a("p",[t._v("触发Reflow")]),t._v(" "),a("p",[t._v("当你增加、删除、修改DOM结点时候，会导致Reflow和Repaint\n（修改DOM或者修改元素形状大小，就会触发reflow）\n当你移动DOM的位置，或者搞个动画的时候\n当你修改CSS样式的时候\n当你Resize窗口的时候（移动端没有这个问题），或者滚动的时候\n当你修改网页的默认字体的时候\nRrpaint 页面的内容挂到界面上就是Repaint\n判断现在呈现的内容有没有造成变化，触发Repaint\n避免Reflow\n减少Repaint（DOM改动，CSS改动）\nRepaint不可以避免，但是可以减少")]),t._v(" "),a("p",[t._v("提升页面性能的方法有哪些？\n1。资源压缩合并，减少HTTP请求\n2.非核心代码异步加载=》异步加载的方式=》异步加载的区别\n3.利用浏览器缓存=》缓存的分类=》缓存的原理\n强缓存（cache-control）\n协商缓存：发起http请求到浏览器缓存，如果请求的缓存结果失效，那就返回缓存标实，带着这个标实发起HTTP请求，304资源无更新，获取该请求的缓存结果，然后浏览器缓存返回该请求的缓存结果。")]),t._v(" "),a("p",[t._v("Last-Modifided和id-Modefied-Since\n浏览器第一次访问资源时，reponse header里面加上了Last0Modefied的header，值是这个资源在服务器上最后修改时间，浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200")]),t._v(" "),a("p",[t._v("ETag和If-None-Match\nEtag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。")]),t._v(" "),a("p",[t._v("作者：浪里行舟\n链接：https://www.jianshu.com/p/54cc04190252\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")]),t._v(" "),a("p",[t._v('4.使用CDN\n5.预解析DNS\nhttp-equiv="x-dns-prefetch-control" content="on"\n预解析dns')]),t._v(" "),a("h2",{attrs:{id:"错误监控类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#错误监控类"}},[t._v("#")]),t._v(" 错误监控类")]),t._v(" "),a("h3",{attrs:{id:"错误的捕获方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#错误的捕获方式"}},[t._v("#")]),t._v(" 错误的捕获方式")]),t._v(" "),a("ul",[a("li",[t._v("即时运行错误的捕获方式\n（1）try... catch\n(2) window.onerror")]),t._v(" "),a("li",[t._v("资源加载错误\n（1）object.onerror\n(2)performance.getEntries()\n(3) Error事件捕获\njs本事呢好死跨域的，那跨域的js运行错误可以拿到吗，但跨域文件的错误，只能拿到个出错了，拿不到具体错误信息。但可以在1. script标签增加crossorign属性（客户端）2. 设置js资源响应头Access-Control-Allow-Orign")])]),t._v(" "),a("h3",{attrs:{id:"上报错误的基本原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上报错误的基本原理"}},[t._v("#")]),t._v(" 上报错误的基本原理")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("采用AJAX的方式")])]),t._v(" "),a("li",[a("p",[t._v("利用Image对象上报\n(new Image()).src='http://baidu.com/tesjik?r=tkjj'\n这样请求就发出去了")])])]),t._v(" "),a("h2",{attrs:{id:"mvvm框架类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm框架类"}},[t._v("#")]),t._v(" MVVM框架类")]),t._v(" "),a("h3",{attrs:{id:"设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")])])}),[],!1,null,null,null);e.default=r.exports}}]);