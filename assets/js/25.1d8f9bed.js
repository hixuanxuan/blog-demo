(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{303:function(t,s,a){"use strict";a.r(s);var e=a(16),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"创建更新的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建更新的方式"}},[t._v("#")]),t._v(" 创建更新的方式")]),t._v(" "),a("ul",[a("li",[t._v("ReactDOM.render || hydrate")]),t._v(" "),a("li",[t._v("setState")]),t._v(" "),a("li",[t._v("forceUpdate")])]),t._v(" "),a("h3",{attrs:{id:"步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#步骤"}},[t._v("#")]),t._v(" 步骤")]),t._v(" "),a("ul",[a("li",[t._v("创建ReactRoot")]),t._v(" "),a("li",[t._v("创建FiberRoot和RootFiber")]),t._v(" "),a("li",[t._v("创建更新（进入调度后就是调度器负责）")])]),t._v(" "),a("h2",{attrs:{id:"react-fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[t._v("#")]),t._v(" react Fiber")]),t._v(" "),a("p",[t._v("React16后，迎来了react fiber。\nFiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    stateNode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 节点实例")]),t._v("\n    child"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子节点")]),t._v("\n    sibling"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 兄弟节点")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("       "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 父节点")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Fiber Reconciler 每执行一段时间，都会将控制权交回给浏览器，可以分段执行.")]),t._v(" "),a("h2",{attrs:{id:"fiberroot"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fiberroot"}},[t._v("#")]),t._v(" FiberRoot")]),t._v(" "),a("h3",{attrs:{id:"_1-1-作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-作用"}},[t._v("#")]),t._v(" 1.1 作用")]),t._v(" "),a("ul",[a("li",[t._v("整个应用的起点")]),t._v(" "),a("li",[t._v("包含应用挂载的目标结点")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<div id='root'>root</div\n")])])]),a("ul",[a("li",[t._v("记录整个应用更新过程的各种信息")])]),t._v(" "),a("h3",{attrs:{id:"_1-2-与rootfiber的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-与rootfiber的关系"}},[t._v("#")]),t._v(" 1.2 与RootFiber的关系")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("FiberRoot"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("current "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" RootFiber\nRootFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("stateNode "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" FiberRoot\n")])])]),a("h3",{attrs:{id:"_1-3-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-api"}},[t._v("#")]),t._v(" 1.3 api")]),t._v(" "),a("p",[a("code",[t._v("createFiberRoot()")])]),t._v(" "),a("p",[t._v("作用：初始化fiberRoot和rootFiber")]),t._v(" "),a("h2",{attrs:{id:"fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fiber"}},[t._v("#")]),t._v(" Fiber")]),t._v(" "),a("ul",[a("li",[t._v("每一个reactElement对应一个Fiber对象")]),t._v(" "),a("li",[t._v("记录节点的各种状态（比如class component的state和props，记录在Fiber上面，在Fiber上操作，更新了之后才能放在state和props上面，这样也给日后的Hook形成了方便，虽然Hook没有this，但是我们的操作都在Fiber上面）")]),t._v(" "),a("li",[t._v("串联整个应用（在ReactElement里面 通过 props.Children 把每个结点都串联起来，Fiber里面也有这个能力把结点串联起来）")])]),t._v(" "),a("p",[t._v("React Fiber的工作分为下面两个阶段")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("render/reconcilition：寻找Element Tree的更新点，并转换成合并为单次Dom操作。")])]),t._v(" "),a("li",[a("p",[t._v("commit： 这个阶段主要是把上个阶段生成的DOM操作去真正的执行。")])])]),t._v(" "),a("p",[t._v("对比新老算法：\n老的算法的执行是：Render -> 只要出发就不停的一大堆计算 -> commit 提交\n新的算法的执行是：Render -> 一个个小的工作单元  ----\x3e 异步执行完成后 -> commit提交 ---\x3e 异步分散在不同的帧中执行\nfiber这种数据结构是原有React的元素数据结构的升级版，它包含了每个fiber对应的元素的信息、该元素的更新操作队列、类型等。\n下面是Fiber")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Fiber对应一个组件需要被处理或者已经处理了，一个组件可以有一个或者多个Fiber")]),t._v("\ntype Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 标记不同的组件类型")]),t._v("\n  tag"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" WorkTag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ReactElement里面的key")]),t._v("\n  key"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ReactElement.type，也就是我们调用`createElement`的第一个参数")]),t._v("\n  elementType"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The resolved function/class/ associated with this fiber.")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 异步组件resolved之后返回的内容，一般是`function`或者`class`")]),t._v("\n  type"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The local state associated with this fiber.")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）")]),t._v("\n  stateNode"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 单链表树结构")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向自己的第一个子节点")]),t._v("\n  child"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向自己的兄弟结构")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 兄弟节点的return指向同一个父节点")]),t._v("\n  sibling"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  index"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ref属性")]),t._v("\n  ref"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("handle"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" mixed")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("_stringRef"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v("string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" RefObject"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 新的变动带来的新的props")]),t._v("\n  pendingProps"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上一次渲染完成之后的props")]),t._v("\n  memoizedProps"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 该Fiber对应的组件产生的Update会存放在这个队列里面")]),t._v("\n  updateQueue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" UpdateQueue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("any"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上一次渲染的时候的state")]),t._v("\n  memoizedState"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一个列表，存放这个Fiber依赖的context")]),t._v("\n  firstContextDependency"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ContextDependency"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("mixed"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用来描述当前Fiber和他子树的`Bitfield`")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 共存的模式表示这个子树是否默认是异步渲染的")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Fiber被创建的时候他会继承父Fiber")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 其他的标识也可以在创建的时候被设置")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但是在创建之后不应该再被修改，特别是他的子Fiber创建之前")]),t._v("\n  mode"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" TypeOfMode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Effect")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用来记录Side Effect")]),t._v("\n  effectTag"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" SideEffectTag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 单链表用来快速查找下一个side effect")]),t._v("\n  nextEffect"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子树中第一个side effect")]),t._v("\n  firstEffect"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子树中最后一个side effect")]),t._v("\n  lastEffect"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代表任务在未来的哪个时间点应该被完成")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不包括他的子树产生的任务")]),t._v("\n  expirationTime"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ExpirationTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 快速确定子树中是否有不在等待的变化")]),t._v("\n  childExpirationTime"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ExpirationTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 我们称他为`current <==> workInProgress`")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在渲染完成之后他们会交换位置")]),t._v("\n  alternate"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 下面是调试相关的，收集每个Fiber和子树渲染时间的")]),t._v("\n\n  actualDuration"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// If the Fiber is currently active in the "render" phase,')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This marks the time at which the work began.")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This field is only set when the enableProfilerTimer flag is enabled.")]),t._v("\n  actualStartTime"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Duration of the most recent render time for this Fiber.")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This value is not updated when we bailout for memoization purposes.")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This field is only set when the enableProfilerTimer flag is enabled.")]),t._v("\n  selfBaseDuration"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Sum of base times for all descedents of this Fiber.")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// This value bubbles up during the "complete" phase.')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This field is only set when the enableProfilerTimer flag is enabled.")]),t._v("\n  treeBaseDuration"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Conceptual aliases")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// workInProgress : Fiber ->  alternate The alternate used for reuse happens")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// to be the same as work in progress.")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// __DEV__ only")]),t._v("\n  _debugID"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  _debugSource"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Source "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  _debugOwner"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  _debugIsCurrentlyTiming"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" boolean"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h2",{attrs:{id:"不同的expiration-time"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不同的expiration-time"}},[t._v("#")]),t._v(" 不同的expiration Time")]),t._v(" "),a("p",[t._v("在React中，为防止某个update因为优先级的原因一直被打断而未能执行。React会设置一个ExpirationTime（在这个时间你都可以打断我），当时间到了ExpirationTime的时候，如果某个update还未执行的话，React将会强制执行该update（强制把这个任务执行）。")]),t._v(" "),a("h3",{attrs:{id:"_1-1-种类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-种类"}},[t._v("#")]),t._v(" 1.1 种类")]),t._v(" "),a("ul",[a("li",[t._v("Sync模式（优先级最高，任务创建之后就要立即更新到dom）")]),t._v(" "),a("li",[t._v("异步模式（优先级较低，可能被中断，但优先级不同）")]),t._v(" "),a("li",[t._v("指定context")])])])}),[],!1,null,null,null);s.default=n.exports}}]);